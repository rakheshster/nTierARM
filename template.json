{
    "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "tierNames": {
            "type": "string",
            "metadata": {
                "description": "A space separated list of tiers (leave at default if none)"
            },
            "defaultValue": "<none>"
            // note to future self: I have to workaround like this because an empty string becomes an array of one "emptiness" apparently
            // when I split later. so I need to put some placeholder text I can match against as the default. 
            // the alternative is to not have a default value and so the array is empty. but this fails because then ARM considers the array
            // as not existing in the first place. so I will have to do a hack like proxy this array. 
            // see https://stackoverflow.com/questions/53722613/arm-resource-iteration-failing-with-an-empty-array for some context
        },
        "mgmtSubnetRequired": {
            "type": "bool",
            "metadata": {
                "description": "Do you want a management/ hub subnet?"
            },
            "defaultValue": true
        },
        "vnetNumber": {
            "type": "string",
            "allowedValues": [
                "01", "02", "03", "04"
            ],
            "metadata": {
                "description": "01 if for vnet01, 02 for vnet02, and so on ..."
            },
            "defaultValue": "01"
        },
        "createPeering": {
            "type": "bool",
            "metadata": {
                "description": "Create peering to hub vnet?"
            },
            "defaultValue": true
        }
    },
    "variables": {
        // these are my various sites and their properties - I use this to get the code based on selections above
        // subnetGap is how I increment the 3rd octet for each subnet/ tier. if I change this be sure to change subnetSize mask.
        // its easier to think of subnetGap as how many /24 subnets I am combining for that subnet's address space. so 2x /24 = /23 hence 2.
        // first octet is constant. second octet is incremented per environment. third octet is incremented per subnet. last octet is the host address.
        "siteDefs": {
            // Ireland
            "northeurope": {
                "sitePrefix": "eu1", 
                "octet1": 10, "octet2": 110, "octet3": 0, "subnetSize": "0/23", "subnetGap": 2, "addressSpace": "/16"
            },
            // Amsterdam (DR)
            "westeurope": {
                "sitePrefix": "eu2", 
                "octet1": 10, "octet2": 210, "octet3": 0, "subnetSize": "0/23", "subnetGap": 2, "addressSpace": "/16"
            },
            // Toronto
            "canadacentral": {
                "sitePrefix": "am1", 
                "octet1": 10, "octet2": 120, "octet3": 0, "subnetSize": "0/23", "subnetGap": 2, "addressSpace": "/16"
            },
            // Quebec (DR)
            "canadaeast": {
                "sitePrefix": "am2", 
                "octet1": 10, "octet2": 220, "octet3": 0, "subnetSize": "0/23", "subnetGap": 2, "addressSpace": "/16"
            },
            // Hong Kong
            "eastasia": {
                "sitePrefix": "ap1", 
                "octet1": 10, "octet2": 130, "octet3": 0, "subnetSize": "0/23", "subnetGap": 2, "addressSpace": "/16"
            },
            // Singapore (DR)
            "southeastasia": {
                "sitePrefix": "ap2", 
                "octet1": 10, "octet2": 230, "octet3": 0, "subnetSize": "0/23", "subnetGap": 2, "addressSpace": "/16"
            }
        },
        // setting these variables so I can refer to them easily later rather than use the long form referencing the array
        "azlocation": "[resourceGroup().location]",
        "sitePrefix": "[variables('siteDefs')[variables('azlocation')].sitePrefix]",

        // figuring out the environment suffix based on the resurce group name. I need this for the resources I create. 
        // the resource group (which is pre-created) is of the format <sitePrefix>-rg[u|p|pp|d] so I can extract the last char to get suffix
        "environmentSuffix": "[toLower(last(resourceGroup().name))]",
        "envDefs": {
            "p":  { "envIncrement": 0 },
            "e":  { "envIncrement": 1 },
            "u":  { "envIncrement": 2 },
            "d":  { "envIncrement": 3 },
            "h":  { "envIncrement": 4 } // if you change this be sure to change the hubvnetName etc. variables below
        },

        // I create my real octets based on the env & region; then create variables for addressSpace and addressPrefix so I can use them easily later
        "octet1": "[variables('siteDefs')[variables('azlocation')].octet1]",
        "octet2": "[add(variables('siteDefs')[variables('azlocation')].octet2, variables('envDefs')[variables('environmentSuffix')].envIncrement)]",
        "octet3": "[variables('siteDefs')[variables('azlocation')].octet3]",

        "subnetSize": "[variables('siteDefs')[variables('azlocation')].subnetSize]",
        "subnetGap": "[variables('siteDefs')[variables('azlocation')].subnetGap]",
        "addressSpace": "[concat(variables('octet1'), '.', variables('octet2'), '.', variables('octet3'), '.0', variables('siteDefs')[variables('azlocation')].addressSpace)]",
        "addressPrefix": "[concat(variables('octet1'), '.', variables('octet2'))]",
        "vnetName": "[concat(variables('sitePrefix'), '-vnet', parameters('vnetNumber'), variables('environmentSuffix'))]",

        // calculate the hub resource groups's vnet name etc. so I can use it for peering later if it exists
        "hubvnetName": "[replace(variables('vnetName'), variables('environmentSuffix'), 'h')]",
        "hubrgName": "[replace(resourceGroup().name, variables('environmentSuffix'), 'h')]",
        "hubvnetID": "[resourceId(variables('hubrgName'), 'Microsoft.Network/virtualNetworks', variables('hubvnetName'))]",
        "huboctet1": "[variables('siteDefs')[variables('azlocation')].octet1]",
        "huboctet2": "[add(variables('siteDefs')[variables('azlocation')].octet2, variables('envDefs').h.envIncrement)]",
        "huboctet3": "[variables('siteDefs')[variables('azlocation')].octet3]",
        "hubaddressSpace": "[concat(variables('huboctet1'), '.', variables('huboctet2'), '.', variables('huboctet3'), '.0', variables('siteDefs')[variables('azlocation')].addressSpace)]",

        // put the tier names in an array so I can loop over them later.
        "tiersArray": "[split(parameters('tierNames'), ' ')]",
        "mgmtTier": "[if(parameters('mgmtSubnetRequired'), 'mgmt', 'unused')]"
    },
    "resources": [
        // === Network Security Groups ===
        {
            // skip if we have zero tiers
            "condition": "[not(equals(variables('tiersArray')[0], '<none>'))]",
            "type": "Microsoft.Network/networkSecurityGroups",
            "apiVersion": "2020-05-01",
            // the name is <site code>-<tier name>-nsg<env suffix>
            "name": "[concat(variables('sitePrefix'), '-', toLower(variables('tiersArray')[copyIndex()]), '-nsg', variables('environmentSuffix'))]",
            "location": "[variables('azLocation')]",
            "properties": {
                "securityRules": []
            },
            "copy": {
                "name": "nsg-loop",
                "count": "[length(variables('tiersArray'))]"
            }
        },
        // === Virtual Networks ===
        {
            "type": "Microsoft.Network/virtualNetworks",
            "apiVersion": "2020-05-01",
            "name": "[variables('vnetName')]",
            "location": "[variables('azLocation')]",
            "properties": {
                // I could do the peerings here I suppose but I chose to do it as a separate thing later so I can conditionally do it
                "virtualNetworkPeerings": [],
                "enableDdosProtection": false,
                "enableVmProtection": false,
                "addressSpace": {
                    "addressPrefixes": [
                        "[variables('addressSpace')]"
                    ]
                }
                // subnets are created later on. initially I was doing a copy block here but that failed coz applying an NSG on GatewaySubnet is disallowed
                // and I couldn't put in a condition block within a copy block. so I split out subnet creation for later. 
            }
        },
        // === Virtual Network Peerings ===
        {
            "condition": "[parameters('createPeering')]",
            "type": "Microsoft.Network/virtualNetworks/virtualNetworkPeerings",
            "name": "[concat(variables('vnetName'), '/', variables('vnetName'),'_',variables('hubvnetName'),'-peering')]",
            "dependsOn": [
                "[resourceId('Microsoft.Network/virtualNetworks', variables('vnetName'))]"
            ],
            "apiVersion": "2020-07-01",
            "properties": {
                "allowVirtualNetworkAccess": true,
                "allowForwardedTraffic": true,
                "allowGatewayTransit": false,
                "useRemoteGateways": false,
                "remoteVirtualNetwork": {
                    "id": "[variables('hubvnetID')]"
                },
                "remoteAddressSpace": {
                    "addressPrefixes": [
                        "[variables('hubaddressSpace')]"
                    ]
                },
                "peeringState": "Connected"
            }
        },
        // === Subnets ===
        {
            // skip if we have zero tiers
            "condition": "[not(equals(variables('tiersArray')[0], '<none>'))]",
            "type": "Microsoft.Network/virtualNetworks/subnets",
            // dont do this for the GatewaySubnet or Unused subnet
            "apiVersion": "2020-07-01",
            // the name is <vnetName>/<tierName>
            "name": "[concat(variables('vnetName'), '/', variables('tiersArray')[copyIndex()])]",
            "properties": {
                // I want to leave the 0 subnet free (e.g. 10.110.0) and start from 2 (or whatever the gap is) instead (10.110.2). 
                // Hence I do a little addition below to copyIndex() :)
                "addressPrefix": "[concat(variables('addressPrefix'), '.', mul(variables('subnetGap'),add(1,copyIndex())), '.', variables('subnetSize'))]",
                "networkSecurityGroup": {
                    "id": "[resourceId('Microsoft.Network/networkSecurityGroups', concat(variables('sitePrefix'), '-', toLower(variables('tiersArray')[copyIndex()]), '-nsg', variables('environmentSuffix')))]"
                }
            },
            "dependsOn": [
                // I need the NSGs created, so I make that loop a dependency
                // thanks to https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/define-resource-dependency#depend-on-resources-in-a-loop
                "nsg-loop"
            ],
            // loop over each of my tiers to create this per tier
            "copy": {
                "name": "subnet-loop",
                "count": "[length(variables('tiersArray'))]"
            }
        },
        // === Special case of the first subnet that I skipped above ===
        // this is same as above except it has no NSG
        {
            "type": "Microsoft.Network/virtualNetworks/subnets",
            // special case for the GatewaySubnet
            "apiVersion": "2020-07-01",
            // the name is <vnetName>/<tierName>
            "name": "[concat(variables('vnetName'), '/', variables('mgmtTier'))]",
            "properties": {
                "addressPrefix": "[concat(variables('addressPrefix'), '.0.', variables('subnetSize'))]"
            },
            "dependsOn": [
                "[resourceId('Microsoft.Network/virtualNetworks', variables('vnetName'))]"
            ]
        },
        // === Public IPs for my Load Balancers ===
        {
            // skip if we have zero tiers
            "condition": "[not(equals(variables('tiersArray')[0], '<none>'))]",
            "type": "Microsoft.Network/publicIPAddresses",
            "apiVersion": "2020-07-01",
            // the name is <site code>-<tier name>-lbpip<env suffix>
            "name": "[concat(variables('sitePrefix'), '-', toLower(variables('tiersArray')[copyIndex()]), '-lbpip', variables('environmentSuffix'))]",
            "location": "[variables('azlocation')]",
            "sku": {
                "name": "Standard"
            },
            "properties": {
                "publicIPAddressVersion": "IPv4",
                "publicIPAllocationMethod": "Static",
                "idleTimeoutInMinutes": 4,
                "ipTags": []
            },
            // loop over each of my tiers to create this per tier
            "copy": {
                "name": "lbpip-loop",
                "count": "[length(variables('tiersArray'))]"
            }
        },
        // === Load Balancers ===
        {
            // skip if we have zero tiers
            "condition": "[not(equals(variables('tiersArray')[0], '<none>'))]",
            "type": "Microsoft.Network/loadBalancers",
            "apiVersion": "2020-05-01",
            // the name is <site code>-<tier name>-lb<env suffix>
            "name": "[concat(variables('sitePrefix'), '-', toLower(variables('tiersArray')[copyIndex()]), '-lb', variables('environmentSuffix'))]",
            "location": "[variables('azlocation')]",
            "dependsOn": [
                // I need the Public IPs created, so I make that loop a dependency
                "lbpip-loop"
            ],
            "sku": {
                "name": "Standard"
            },
            "properties": {
                "frontendIPConfigurations": [
                    {
                        "name": "LoadBalancerFrontEnd",
                        "properties": {
                            "privateIPAllocationMethod": "Dynamic",
                            "publicIPAddress": {
                                "id": "[resourceId('Microsoft.Network/publicIPAddresses', concat(variables('sitePrefix'), '-', toLower(variables('tiersArray')[copyIndex()]), '-lbpip', variables('environmentSuffix')))]"
                            },
                            "privateIPAddressVersion": "IPv4"
                        }
                    }
                ],
                "backendAddressPools": [],
                "loadBalancingRules": [],
                "probes": [],
                "inboundNatRules": [],
                "outboundRules": [],
                "inboundNatPools": []
            },
            // loop over each of my tiers to create this per tier
            "copy": {
                "name": "lb-loop",
                "count": "[length(variables('tiersArray'))]"
            }
        }
    ]
}